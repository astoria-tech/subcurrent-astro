import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import dotenv from 'dotenv';
import DOMPurify from 'isomorphic-dompurify';
import { XMLParser } from 'fast-xml-parser';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, '../..');
dotenv.config({ path: path.join(rootDir, '.env') });

// Define the URL to the RSS feed generated by your site
const RSS_FEED_URL =
  process.env.RSS_FEED_URL || 'https://astoria-tech.github.io/subcurrent-astro/rss.xml';
const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;
const MAX_NOTIFICATIONS = 5; // Maximum number of notifications to send per run

// Path to store the record of posts we've already sent to Discord
const SENT_POSTS_FILE = path.join(__dirname, '../../.discord-sent-posts.json');

// Log environment variable status for troubleshooting
if (!DISCORD_WEBHOOK_URL) {
  console.warn(
    'DISCORD_WEBHOOK_URL not found in environment variables. ' +
      'When running locally, make sure you have a .env file with DISCORD_WEBHOOK_URL set.'
  );
}
interface RssItem {
  title: string;
  link: string;
  pubDate: string;
  description?: string;
  author?: string;
  imageUrl?: string;
}

interface PostsTracker {
  sentPosts: string[];
  latestTimestamp: string;
}

interface DiscordEmbed {
  title: string;
  url: string;
  description: string;
  color: number;
  timestamp: string;
  footer: {
    text: string;
  };
  image?: {
    url: string;
  };
}

// Helper function to properly decode HTML entities and clean content
function sanitizeContent(html: string): string {
  if (!html) return '';

  // Use DOMPurify's sanitize function to safely parse the HTML
  // This automatically handles all HTML entities properly
  const sanitized = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [], // No tags allowed, we just want text
    ALLOWED_ATTR: [], // No attributes allowed
  });

  // Trim excess whitespace
  return sanitized.replace(/\s+/g, ' ').trim();
}

async function loadPostsTracker(): Promise<PostsTracker> {
  try {
    const data = await fs.readFile(SENT_POSTS_FILE, 'utf-8');
    const tracker = JSON.parse(data) as PostsTracker;
    return {
      sentPosts: Array.isArray(tracker.sentPosts) ? tracker.sentPosts : [],
      latestTimestamp: tracker.latestTimestamp || '1970-01-01T00:00:00.000Z',
    };
  } catch (error) {
    // File doesn't exist or is invalid, start with empty tracker
    console.log('State file not found or invalid. Creating a new tracker.');
    console.log('Note: MAX_NOTIFICATIONS setting will limit initial notifications to:', MAX_NOTIFICATIONS);
    
    return {
      sentPosts: [],
      latestTimestamp: '1970-01-01T00:00:00.000Z',
    };
  }
}

async function savePostsTracker(tracker: PostsTracker): Promise<void> {
  await fs.writeFile(SENT_POSTS_FILE, JSON.stringify(tracker, null, 2), 'utf-8');
}

async function fetchRss(): Promise<RssItem[]> {
  console.log(`Fetching RSS feed from ${RSS_FEED_URL}`);
  const response = await fetch(RSS_FEED_URL);

  if (!response.ok) {
    throw new Error(`Failed to fetch RSS feed: ${response.status} ${response.statusText}`);
  }

  const content = await response.text();

  // Configure XML parser with appropriate options to handle RSS feeds
  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: '@_',
    isArray: (name) => name === 'item', // Ensure items are always treated as an array
    // Preserve CDATA content
    cdataPropName: '__cdata',
    // Handle whitespace
    preserveOrder: false,
    trimValues: true,
    parseTagValue: true,
  });

  try {
    const result = parser.parse(content);
    const items: RssItem[] = [];

    // Check if we have valid RSS structure
    if (!result.rss || !result.rss.channel) {
      console.warn('RSS feed does not have expected structure');
      return [];
    }

    // Extract items from RSS feed - handle both array and single item cases
    const rssItems = result.rss.channel.item || [];

    for (const item of rssItems) {
      // Extract and decode fields
      // Handle both direct values and CDATA wrapped content
      const getField = (field: string): string => {
        if (!item[field]) return '';

        // Handle CDATA wrapped content
        if (item[field].__cdata) return item[field].__cdata;

        // Handle direct text
        return item[field].toString();
      };

      const title = getField('title');
      const link = getField('link');
      const pubDate = getField('pubDate');
      const author = getField('author') || getField('dc:creator');
      const description = getField('description');

      // Extract image URL using various common RSS patterns
      let imageUrl = '';

      // Try media:content
      if (item['media:content'] && item['media:content']['@_url']) {
        imageUrl = item['media:content']['@_url'];
      }
      // Try media:thumbnail
      else if (item['media:thumbnail'] && item['media:thumbnail']['@_url']) {
        imageUrl = item['media:thumbnail']['@_url'];
      }
      // Try enclosure (podcasts and some blogs)
      else if (
        item.enclosure &&
        item.enclosure['@_url'] &&
        item.enclosure['@_type'] &&
        item.enclosure['@_type'].startsWith('image/')
      ) {
        imageUrl = item.enclosure['@_url'];
      }
      // Try image tag directly
      else if (item.image && item.image.url) {
        imageUrl = item.image.url;
      }
      // Try itunes:image
      else if (item['itunes:image'] && item['itunes:image']['@_href']) {
        imageUrl = item['itunes:image']['@_href'];
      }
      // If no image found in standard tags, try to extract from description
      else if (description) {
        const imgMatch = description.match(/<img[^>]+src="([^">]+)"/i);
        if (imgMatch && imgMatch[1]) {
          imageUrl = imgMatch[1];
        }
      }

      items.push({
        title: title.trim(),
        link: link.trim(),
        pubDate: pubDate.trim(),
        author: author.trim(),
        description: description.trim(),
        imageUrl: imageUrl.trim(),
      });
    }

    return items;
  } catch (error) {
    console.error('Error parsing RSS feed:', error);
    // Fallback to returning an empty array
    return [];
  }
}

async function sendToDiscord(item: RssItem): Promise<void> {
  if (!DISCORD_WEBHOOK_URL) {
    console.error(
      'Discord webhook URL not provided. Set DISCORD_WEBHOOK_URL environment variable.'
    );
    return;
  }

  try {
    // Clean up the title and description for better presentation
    const cleanTitle = sanitizeContent(item.title);
    const cleanDescription = item.description ? sanitizeContent(item.description) : '';

    // Create a rich embed for Discord
    const embed: DiscordEmbed = {
      title: cleanTitle,
      url: item.link,
      description: cleanDescription
        ? cleanDescription.length > 200
          ? cleanDescription.substring(0, 200) + '...'
          : cleanDescription
        : 'Read more at the link',
      color: 0x3498db, // Blue color
      timestamp: new Date(item.pubDate).toISOString(),
      footer: {
        text: `Posted by ${item.author || '(author not provided)'}`,
      },
    };

    // Add image if available
    if (item.imageUrl) {
      // Validate image URL
      const isValidUrl = (url: string): boolean => {
        try {
          new URL(url);
          return url.startsWith('http://') || url.startsWith('https://');
        } catch (e) {
          return false;
        }
      };

      if (isValidUrl(item.imageUrl)) {
        embed.image = {
          url: item.imageUrl,
        };
        console.log(`Including image: ${item.imageUrl}`);
      }
    }

    const payload = {
      embeds: [embed],
    };

    console.log(`Sending notification for "${cleanTitle}"`);

    const response = await fetch(DISCORD_WEBHOOK_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Discord API error: ${response.status} ${response.statusText}`);
    }

    // Add a small delay to avoid rate limiting
    await new Promise((resolve) => setTimeout(resolve, 1000));
  } catch (error) {
    console.error(`Failed to send Discord notification for ${item.title}:`, error);
  }
}

async function notifyNewItems(): Promise<void> {
  if (!DISCORD_WEBHOOK_URL) {
    console.error(
      'Discord webhook URL not provided. Set DISCORD_WEBHOOK_URL environment variable.'
    );
    return;
  }

  try {
    // Load the tracker of posts we've already sent
    const tracker = await loadPostsTracker();
    const sentPostsSet = new Set(tracker.sentPosts);
    const latestTimestamp = new Date(tracker.latestTimestamp);

    console.log(`Last notification timestamp: ${latestTimestamp.toISOString()}`);

    // Fetch current RSS items
    const items = await fetchRss();

    // Sort by publication date (newest first)
    items.sort((a, b) => new Date(b.pubDate).getTime() - new Date(a.pubDate).getTime());

    // Find items we haven't sent yet AND are newer than our latest post
    const newItems = items.filter((item) => {
      const itemDate = new Date(item.pubDate);
      return !sentPostsSet.has(item.link) && itemDate > latestTimestamp;
    });

    console.log(`Found ${newItems.length} new items to notify about`);

    // Send notifications for new items (up to the maximum limit)
    const itemsToSend = newItems.slice(0, MAX_NOTIFICATIONS);
    let newLatestTimestamp = latestTimestamp;

    for (const item of itemsToSend) {
      await sendToDiscord(item);
      sentPostsSet.add(item.link);

      // Update latest timestamp if this item is newer
      const itemDate = new Date(item.pubDate);
      if (itemDate > newLatestTimestamp) {
        newLatestTimestamp = itemDate;
      }
    }

    // Save the updated tracker with new latest timestamp
    const updatedTracker: PostsTracker = {
      sentPosts: Array.from(sentPostsSet),
      latestTimestamp: newLatestTimestamp.toISOString(),
    };
    await savePostsTracker(updatedTracker);

    console.log(`Successfully sent ${itemsToSend.length} notifications to Discord`);
    if (itemsToSend.length > 0) {
      console.log(`Updated latest timestamp to: ${newLatestTimestamp.toISOString()}`);
    }
  } catch (error) {
    console.error('Error in Discord notification process:', error);
  }
}

// Only run if this file is executed directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  notifyNewItems().catch((error) => {
    console.error('Fatal error in Discord notifier:', error);
    process.exit(1);
  });
}

export { notifyNewItems };
